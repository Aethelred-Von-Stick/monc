!> MONC program entry point which simply calls the main procedure in the MONC module
!  
program monc_driver
#ifdef IO_SERVER
  use io_server_mod, only : io_server_run
#endif
  use monc_mod, only : monc_core_bootstrap
  use monc_component_mod, only : component_descriptor_type
  use collections_mod, only : list_type, c_add
  ! Include the autogenerated use modules for each of the components
#ifdef USE_MAKE
#include "components/componentheaders.autogen"
#include "testcases/testcaseheaders.autogen"
#else
#include "componentheaders.static"
#include "testcaseheaders.static"
#endif
  implicit none

  type(list_type) :: component_descriptions

  call get_compiled_components(component_descriptions)
#ifdef IO_SERVER
  call monc_core_bootstrap(component_descriptions, io_server_run=io_server_run)
#else
  call monc_core_bootstrap(component_descriptions)
#endif
contains

  subroutine get_compiled_components(component_descriptions)
    type(list_type), intent(inout) :: component_descriptions

    ! Include the autogenerated registration calls for each of the components
#ifdef USE_MAKE
#include "components/componentregistrations.autogen"
#include "testcases/testcaseregistrations.autogen"
#else
#include "componentregistrations.static"
#include "testcaseregistrations.static"
#endif
  end subroutine get_compiled_components  

  !> Called by each component to add itself to the registration list_type
  subroutine add_component(component_descriptions, single_description)
    type(list_type), intent(inout) :: component_descriptions
    type(component_descriptor_type), intent(in) :: single_description

    class(*), pointer :: raw_data
    allocate(raw_data, source=single_description)
    call c_add(component_descriptions, raw_data)
  end subroutine add_component
end program monc_driver

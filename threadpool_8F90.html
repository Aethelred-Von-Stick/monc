<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MONC: io/src/threadpool.F90 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MONC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bc161955dc3a3d2485839eba21420d01.html">io</a></li><li class="navelem"><a class="el" href="dir_7913d61037d7093e2ee38526a6ff5887.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#namespaces">Modules</a> &#124;
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">threadpool.F90 File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="threadpool_8F90_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacethreadpool__mod_1_1thread__procedure.html">threadpool_mod::thread_procedure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread call procedure interface.  <a href="interfacethreadpool__mod_1_1thread__procedure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthreadpool__mod_1_1threaded__procedure__container__type.html">threadpool_mod::threaded_procedure_container_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the thread procedure with the call itself and the data to pass to it.  <a href="structthreadpool__mod_1_1threaded__procedure__container__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Modules</h2></td></tr>
<tr class="memitem:namespacethreadpool__mod"><td class="memItemLeft" align="right" valign="top">module &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html">threadpool_mod</a></td></tr>
<tr class="memdesc:namespacethreadpool__mod"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a thread pool and the single management "main" thread will spawn out free threads in the pool to perform specific work. If there are no free threads then it will block until one becomes available. It uses ForThreads, which is a wrapper around pthreads. The thread pool works by creating a number of threads and then passing the work to these threads, rather than creating a new thread for each piece of work. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a05129ab692ec724d569ff6836d12c876"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a05129ab692ec724d569ff6836d12c876">threadpool_mod::threadpool_init</a> (io_configuration)</td></tr>
<tr class="memdesc:a05129ab692ec724d569ff6836d12c876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the thread pool and marks each thread as idle.  <a href="namespacethreadpool__mod.html#a05129ab692ec724d569ff6836d12c876">More...</a><br /></td></tr>
<tr class="separator:a05129ab692ec724d569ff6836d12c876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed96a43d7cd9921cb465a0675bb9546"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#abed96a43d7cd9921cb465a0675bb9546">threadpool_mod::threadpool_lock_netcdf_access</a> ()</td></tr>
<tr class="memdesc:abed96a43d7cd9921cb465a0675bb9546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aquires the NetCDF thread lock, NetCDF is not thread safe so we need to manage thread calls to it.  <a href="namespacethreadpool__mod.html#abed96a43d7cd9921cb465a0675bb9546">More...</a><br /></td></tr>
<tr class="separator:abed96a43d7cd9921cb465a0675bb9546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894eecb849756ec9d8110153283844ee"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a894eecb849756ec9d8110153283844ee">threadpool_mod::threadpool_unlock_netcdf_access</a> ()</td></tr>
<tr class="memdesc:a894eecb849756ec9d8110153283844ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the NetCDF thread lock, NetCDF is not thread safe so we need to manage thread calls to it.  <a href="namespacethreadpool__mod.html#a894eecb849756ec9d8110153283844ee">More...</a><br /></td></tr>
<tr class="separator:a894eecb849756ec9d8110153283844ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a9d51f29634430ca4ed121947b0132"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a66a9d51f29634430ca4ed121947b0132">threadpool_mod::threadpool_start_thread</a> (proc, arguments, data_buffer)</td></tr>
<tr class="memdesc:a66a9d51f29634430ca4ed121947b0132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an idle thread from the pool to execute a specific procedure with some data. If there is no thread available then this will block until one becomes idle.  <a href="namespacethreadpool__mod.html#a66a9d51f29634430ca4ed121947b0132">More...</a><br /></td></tr>
<tr class="separator:a66a9d51f29634430ca4ed121947b0132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe6131baabe8a6b73dbb7e4d5b1aa37"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a9fe6131baabe8a6b73dbb7e4d5b1aa37">threadpool_mod::threadpool_thread_entry_procedure</a> (thread_id)</td></tr>
<tr class="memdesc:a9fe6131baabe8a6b73dbb7e4d5b1aa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point called by each thread creation in the pool, this calls out to the actual procedure to execute and doing it this way allows us to perform some actions before or after which can help with the management of the pool.  <a href="namespacethreadpool__mod.html#a9fe6131baabe8a6b73dbb7e4d5b1aa37">More...</a><br /></td></tr>
<tr class="separator:a9fe6131baabe8a6b73dbb7e4d5b1aa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a87c0e0335c727f6b9fa99c54aac83a"><td class="memItemLeft" align="right" valign="top">logical function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a2a87c0e0335c727f6b9fa99c54aac83a">threadpool_mod::threadpool_is_idle</a> ()</td></tr>
<tr class="memdesc:a2a87c0e0335c727f6b9fa99c54aac83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the thread pool is idle or not (i.e. all threads are idle and waiting for work)  <a href="namespacethreadpool__mod.html#a2a87c0e0335c727f6b9fa99c54aac83a">More...</a><br /></td></tr>
<tr class="separator:a2a87c0e0335c727f6b9fa99c54aac83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046d2df1c16a8ca4876b6dbc4d51d323"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a046d2df1c16a8ca4876b6dbc4d51d323">threadpool_mod::threadpool_deactivate</a> ()</td></tr>
<tr class="memdesc:a046d2df1c16a8ca4876b6dbc4d51d323"><td class="mdescLeft">&#160;</td><td class="mdescRight">This waits for all busy threads to complete and then shuts all the pthreads down. The deactivation and finalisation procedures are split out as we want to deactivate the pool (to ensure no threads are running actions), finalise these actions which might involve destroying mutexes, and then destroying the threading environment in finalisation.  <a href="namespacethreadpool__mod.html#a046d2df1c16a8ca4876b6dbc4d51d323">More...</a><br /></td></tr>
<tr class="separator:a046d2df1c16a8ca4876b6dbc4d51d323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29d0b56c938fe741ebaef345cb86fe7"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#ad29d0b56c938fe741ebaef345cb86fe7">threadpool_mod::threadpool_finalise</a> ()</td></tr>
<tr class="memdesc:ad29d0b56c938fe741ebaef345cb86fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalises the thread pool.  <a href="namespacethreadpool__mod.html#ad29d0b56c938fe741ebaef345cb86fe7">More...</a><br /></td></tr>
<tr class="separator:ad29d0b56c938fe741ebaef345cb86fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c1c7faaf752ec1681acc2bfcce7e16"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a79c1c7faaf752ec1681acc2bfcce7e16">threadpool_mod::find_idle_thread</a> ()</td></tr>
<tr class="memdesc:a79c1c7faaf752ec1681acc2bfcce7e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an idle thread, if one is not available then will block until one becomes free.  <a href="namespacethreadpool__mod.html#a79c1c7faaf752ec1681acc2bfcce7e16">More...</a><br /></td></tr>
<tr class="separator:a79c1c7faaf752ec1681acc2bfcce7e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46884c3dda1e63c2cbaffb985835e64b"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a46884c3dda1e63c2cbaffb985835e64b">threadpool_mod::get_index_of_idle_thread</a> ()</td></tr>
<tr class="memdesc:a46884c3dda1e63c2cbaffb985835e64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifically gets the index of the next idle thread or -1 if they are all busy. This starts from a next suggested idle thread and will wrap around, as often the next thread will be idle rather than searching from the beginning again.  <a href="namespacethreadpool__mod.html#a46884c3dda1e63c2cbaffb985835e64b">More...</a><br /></td></tr>
<tr class="separator:a46884c3dda1e63c2cbaffb985835e64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64977cc4d8fab28cdbfabd03b5f28d3a"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a64977cc4d8fab28cdbfabd03b5f28d3a">threadpool_mod::check_thread_status</a> (ierr)</td></tr>
<tr class="memdesc:a64977cc4d8fab28cdbfabd03b5f28d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the error status of any thread operation and reports an error if it failed.  <a href="namespacethreadpool__mod.html#a64977cc4d8fab28cdbfabd03b5f28d3a">More...</a><br /></td></tr>
<tr class="separator:a64977cc4d8fab28cdbfabd03b5f28d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad7d0516714fa2516b2786d8f3b71ae90"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#ad7d0516714fa2516b2786d8f3b71ae90">threadpool_mod::default_thread_pool_size</a> =10</td></tr>
<tr class="memdesc:ad7d0516714fa2516b2786d8f3b71ae90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads in the pool.  <a href="namespacethreadpool__mod.html#ad7d0516714fa2516b2786d8f3b71ae90">More...</a><br /></td></tr>
<tr class="separator:ad7d0516714fa2516b2786d8f3b71ae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c403e6d28a7ee8246a1ab86533784b"><td class="memItemLeft" align="right" valign="top">logical, dimension(:), allocatable, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a51c403e6d28a7ee8246a1ab86533784b">threadpool_mod::thread_busy</a></td></tr>
<tr class="separator:a51c403e6d28a7ee8246a1ab86533784b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576d78693bfe32e1516e115392d95147"><td class="memItemLeft" align="right" valign="top">logical, dimension(:), allocatable, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a576d78693bfe32e1516e115392d95147">threadpool_mod::thread_start</a></td></tr>
<tr class="separator:a576d78693bfe32e1516e115392d95147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbcbb5ae09bb79b34c270b9d1ca3e23"><td class="memItemLeft" align="right" valign="top">integer, dimension(:), allocatable, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#aedbcbb5ae09bb79b34c270b9d1ca3e23">threadpool_mod::thread_ids</a></td></tr>
<tr class="separator:aedbcbb5ae09bb79b34c270b9d1ca3e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1965300ca8a4b0c408a306b7ca1ce498"><td class="memItemLeft" align="right" valign="top">integer, dimension(:), allocatable, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a1965300ca8a4b0c408a306b7ca1ce498">threadpool_mod::thread_pass_data</a></td></tr>
<tr class="separator:a1965300ca8a4b0c408a306b7ca1ce498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2bb890b5d0b75dcf1879748bb95dc6"><td class="memItemLeft" align="right" valign="top">integer, dimension(:), allocatable, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a7c2bb890b5d0b75dcf1879748bb95dc6">threadpool_mod::activate_thread_condition_variables</a></td></tr>
<tr class="separator:a7c2bb890b5d0b75dcf1879748bb95dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328af7e209159b5a5fea2a4f06015a2e"><td class="memItemLeft" align="right" valign="top">integer, dimension(:), allocatable, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a328af7e209159b5a5fea2a4f06015a2e">threadpool_mod::activate_thread_mutex</a></td></tr>
<tr class="separator:a328af7e209159b5a5fea2a4f06015a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6defef4093bdb19eab5394742524e190"><td class="memItemLeft" align="right" valign="top">type(threaded_procedure_container_type), dimension(:), allocatable, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a6defef4093bdb19eab5394742524e190">threadpool_mod::thread_entry_containers</a></td></tr>
<tr class="separator:a6defef4093bdb19eab5394742524e190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05b961cee29f109c8eb1d4482cd0609"><td class="memItemLeft" align="right" valign="top">integer, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#ac05b961cee29f109c8eb1d4482cd0609">threadpool_mod::netcdfmutex</a></td></tr>
<tr class="memdesc:ac05b961cee29f109c8eb1d4482cd0609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used for controling NetCDF access.  <a href="namespacethreadpool__mod.html#ac05b961cee29f109c8eb1d4482cd0609">More...</a><br /></td></tr>
<tr class="separator:ac05b961cee29f109c8eb1d4482cd0609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4438ba9795846026d38ab75f88afd899"><td class="memItemLeft" align="right" valign="top">integer, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a4438ba9795846026d38ab75f88afd899">threadpool_mod::next_suggested_idle_thread</a></td></tr>
<tr class="separator:a4438ba9795846026d38ab75f88afd899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761369a3259ae6cdc2308f71fab61f44"><td class="memItemLeft" align="right" valign="top">logical, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a761369a3259ae6cdc2308f71fab61f44">threadpool_mod::threadpool_active</a></td></tr>
<tr class="separator:a761369a3259ae6cdc2308f71fab61f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af047904f5bf45ecf31fcf44729da35af"><td class="memItemLeft" align="right" valign="top">integer, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#af047904f5bf45ecf31fcf44729da35af">threadpool_mod::active_threads</a></td></tr>
<tr class="separator:af047904f5bf45ecf31fcf44729da35af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb89aecd148176e33ca7b32da3d60c28"><td class="memItemLeft" align="right" valign="top">integer, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#acb89aecd148176e33ca7b32da3d60c28">threadpool_mod::total_number_of_threads</a></td></tr>
<tr class="separator:acb89aecd148176e33ca7b32da3d60c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371f81756a9676bdb61b852b136dbde4"><td class="memItemLeft" align="right" valign="top">integer, volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethreadpool__mod.html#a371f81756a9676bdb61b852b136dbde4">threadpool_mod::active_scalar_mutex</a></td></tr>
<tr class="separator:a371f81756a9676bdb61b852b136dbde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
